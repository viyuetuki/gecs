---
title: "1. Terminal"
format: html
---

> “Graphical user interfaces make easy tasks easy, while command line interfaces make difficult tasks possible.”
>
> -   William Shotts, *The Linux Command Line: A Complete Introduction*

If there is one software skill you had to learn, it would be working with a UNIX-type shell.

::: {.callout-note appearance="simple"}
Confusion in Terminology

Terminal, Console, Shell, Command Line Interface, Command Line Interpreter, Kernel, and OS are used interchangeably.
:::

# History

![Evolution of operating systems, its kernels, and distributions. <https://www.reddit.com/r/coolguides/comments/k1lopj/os_family_tree/>](images/paste-37.png)

![https://www.reddit.com/r/compsci/comments/kposlx/i_made_a_simple_diagram_on_history_of_os_feel/](images/paste-38.png)

# Opening a Terminal

First, try tyoing gibberish. date uptime df whoami time fo an existensieal question exit

# Navigation

pwd

::: callout-note
Note that the directory separator is a forward slash `/`, not the backslash `\` that you may be used to from Windows or DOS systems.
:::

cd relative(Shortcuts: ., .., -, \~) vs absolute paths

ls

# Exploring Files

ls file less

Options and Arguments `command -optioins arguments` ls -lt

::: callout-caution
Try to avoid any spaces in your directory and file names. Shell interprets space as separator betwenn options or arguments. Space in names will most likely break program producing an error.

You can use spaces by including names in paratheisi or quotes but that is unnecery complication.
:::

::: callout-important
Commands are case sensetive. `ls` is not the same as `LS`, `Ls` or `lS`. Try it!
:::

# Creating Directories and Files

Principles to create files and directories are very similar but, as usual, have their onw terminiology and quirks. We will first look at directories since they are conceptually easier to compehed.

::: {.callout-note title="Folder vs directory"}
Another terminology difference from Windows. Funilly, file is a file.
:::

## Directories

Lets create our first object using the terminal. While in your home directory `~`, type:

``` bash
mkdir oist
```

Check with `ls` what happened. `mkdir` stands for **m**a**k**e **dir**ectory.

Looks nice! Let's go inside.

``` bash
cd oist
```

And, check check it out.

``` bash
ls
```

Kind of boring here. There is nothing inside. Let's make some more directories inside.

``` bash
mkdir lab1 lab2 lab3 lab4 lab5
```

There’s something a little different about that command. So far we’ve only seen commands that work on their own (cd, pwd) or that have a single item afterwards (cd /, cd \~/Desktop). But this time we’ve added three things after the mkdir command. Those things are referred to as parameters or arguments, and different commands can accept different numbers of arguments. The mkdir command expects at least one argument, whereas the cd command can work with zero or one, but no more. See what happens when you try to pass the wrong number of parameters to a command:

``` bash
mkdir
cd /etc ~/Desktop
```

Notice that mkdir created all the folders in one directory. It didn’t create `lab3` inside `lab2` inside `lab1`, or any other nested structure. But sometimes it’s handy to be able to do exactly that, and `mkdir` does have a way:

``` bash
mkdir -p lab4/levelE/48
```

ls

You can try to run wihtout `-p` and see wich error message you get.

``` bash
mkdir lab4/levelE/48
```

I find this behaviour annoying. THe same goes for creating files in non-exicsting subdirectories but I am sure there is a good rason behind such restriction.

``` bash
cd lab4
ls
cd levelE
ls
cd ../..
```

The “-p” that we used is called an option or a switch (in this case it means “create the parent directories, too”). Options are used to modify the way in which a command operates, allowing a single command to behave in a variety of different ways. Unfortunately, due to quirks of history and human nature, options can take different forms in different commands. You’ll often see them as single characters preceded by a hyphen (as in this case), or as longer words preceded by two hyphens. The single character form allows for multiple options to be combined, though not all commands will accept that. And to confuse matters further, some commands don’t clearly identify their options at all, whether or not something is an option is dictated purely by the order of the arguments! You don’t need to worry about all the possibilities, just know that options exist and they can take several different forms. For example the following all mean exactly the same thing:

``` bash
# These commands are equivalent
mkdir --parents --verbose lab5/levelDE
mkdir -p --verbose lab5/levelDE
mkdir -p -v lab5/levelDE
mkdir -pv lab5/levelDE
```

## Files

Many labs, right? Can we keep a log of them? `ls` just printed them but can we store this command output in a file? That's where redirecton comes into play.

Suppose we wanted to capture the output of that command as a text file that we can look at or manipulate further. All we need to do is to add the greater-than character (“\>”) to the end of our command line, followed by the name of the file to write to:

``` bash
ls > lab.log
```

This time there’s nothing printed to the screen, because the output is being redirected to our file instead. If you just run ls on its own you should see that the `lab.log` file has been created. We can use the cat command to look at its content:

``` bash
cat lab.log
```

Okay, so it’s not exactly what was displayed on the screen previously, but it contains all the same data, and it’s in a more useful format for further processing.

Let’s look at another command, `echo`:

``` bash
echo "VISION, CHALLENGES, INNOVATION"
```

Yes, echo just prints its arguments back out again (hence the name). But combine it with a redirect, and you’ve got a way to easily create small files. Let's redirect these words into a file that will represent the [Prof. Syndey Brenner](https://en.wikipedia.org/wiki/Sydney_Brenner) statue located at the Center Court.

![Dr. Brenner's statue presented by Okinawa Prefecture and the Council for Promotion of OIST https://www.oist.jp/image/dr-sydney-brenners-statue](images/paste-39.png)

``` bash
echo "VISION, CHALLENGES, INNOVATION" > sydney_brenner.statue
cat sydney_brenner.statue
```

::: {.callout-important title="File extension"}
Linux-type systems do not care about file extensions. Files can have no extensions at all and be absolutely fine. Try redirecting the words output to file named `sydeny_brenner` and see if you can inspect it.
:::

We have one statue but why stop here? It is not improbable that [Prof. Svante Pääbo](http://en.wikipedia.org/wiki/Svante_P%C3%A4%C3%A4bo) will get his statute at OIST in the future. For his statue engraving we will choose something more personal.

``` bash
echo "I really wanted to discover mummies, like Indiana Jones." > svante_paabo.statue
cat svante_paabo.statue
```

However, `cat` is more than just a file viewer - its name comes from ‘con**cat**enate’, meaning “to link together”. If you pass more than one filename to `cat` it will output each of them, one after the other, as a single block of text:

``` bash
cat sydney_brenner.statue svante_paabo.statue
```

Where you want to pass multiple file names to a single command, there are some useful shortcuts that can save you a lot of typing if the files have similar names. A question mark (“?”) can be used to indicate “any single character” within the file name. An asterisk (“\*”) can be used to indicate “zero or more characters”. These are sometimes referred to as “wildcard” characters. A couple of examples might help, the following commands all do the same thing:

``` bash
cat sydney_brenner.statue svante_paabo.statue
cat *.statue
```

That is where file extension `.statue` that we came up with is useful. We can match all statue files no matter how many there are. `lab.log` has been omitted. This simple syntax makes selective manipulation of files an easy task.

::: {.callout-caution appearance="simple"}
As you might have guessed, this capability also means that you need to escape file names with "?" or "\*" characters in them, too. It’s usually better to avoid any punctuation in file names if you want to manipulate them from the command line.
:::

We have not used `?` character above. A somewhat artificial example with our current setup would be to list only the lab directories and their subdirectories:

``` bash
ls lab?
```

Thus we only look at what is inside the directories that start with "lab".

Going back to the statues. Let's join all our files together into a single new file, then view it:

``` bash
cat *.statue > nobel_motivation.txt
cat nobel_motivation.txt
```

What do you think will happen if we run those two commands a second time? Will the computer complain, because the file already exists? Will it append the text to the file, so it contains two copies? Or will it replace it entirely? Give it a try to see what happens, but to avoid typing the commands again you can use the **Up Arrow** and **Down Arrow** keys to move back and forth through the history of commands you’ve used. Press the **Up Arrow** a couple of times to get to the first `cat` and press **Enter** to run it, then do the same again to get to the second.

As you can see, the file looks the same. That’s not because it’s been left untouched, but because the shell clears out all the content of the file before it writes the output of your `cat` command into it. Because of this, you should be extra careful when using redirection to make sure that you don’t accidentally overwrite a file you need. If you do want to append to, rather than replace, the content of the files, double up on the greater-than character "\>\>":

``` bash
cat *.statue > nobel_motivation.txt
echo "I want my statue too!" >> nobel_motivation.txt
cat nobel_motivation.txt
```

Repeat the `echo` a few more times, using the **Up Arrow** for convenience until your text document is so large that it won’t all fit in the terminal at once when you use `cat` to display it. In order to see the whole file we now need to use a different program, called a ***pager*** (because it displays your file one “page” at a time). The standard pager of old was called `more`, because it puts a line of text at the bottom of each page that says “–More–” to indicate that you haven’t read everything yet. These days there’s a far better pager that you should use instead: because it replaces `more`, the programmers decided to call it `less`.

``` bash
less nobel_motivation.txt
```

When viewing a file through `less` you can use the **Up Arrow**, **Down Arrow**, **Page Up**, **Page Down**, **Home** and **End** keys to move through your file. Give them a try to see the difference between them. When you’ve finished viewing your file, press **q** to **q**uit `less` and return to the command line.

::: {.callout-tip title="Good naming practice"}
When you consider both case sensitivity and escaping, a good rule of thumb is to keep your file names all lower case, with only letters, numbers, underscores and hyphens. For files there’s usually also a dot and a few characters on the end to indicate the type of file it is (referred to as the “file extension”). This guideline may seem restrictive, but if you end up using the command line with any frequency you’ll be glad you stuck to this pattern.
:::

If we want to move Sydney to show him the latest lab, Lab 5, how do we do that? Also, is the file we created created empty? How can we check that? `ls` will not work. We will see how files can be manipulated in the next section.

# Manipulating Files

Now that we’ve got a few files, let’s look at the sort of day-to-day tasks you might need to perform on them. In practice you’ll still most likely use a graphical program when you want to move, rename or delete one or two files, but knowing how to do this using the command line can be useful for bulk changes, or when the files are spread amongst different folders. Plus, you’ll learn a few more things about the command line along the way.

Let’s begin by putting our ***svante_paabo.statue*** file into our ***lab1*** directory, using the `mv` (**m**o**v**e) command:

``` bash
mv svante_paabo.statue lab1
```

You can confirm that the job has been done by using `ls` to see that it's missing from the working directory, then `cd lab1` to change into ***lab1***, `ls` to see that it's in there, then `cd ..` to move the working directory back again. Or you could save a lot of typing by passing a path directly to the `ls` command to get straight to the confirmation you're looking for:

``` bash
ls lab1
```

Now suppose it turns out that file shouldn’t be in ***lab1*** after all. Let’s move it back to the working directory. We could `cd` into ***lab1***then use `mv svante_paabo.statue ..` to say “move svante_paabo.statueinto the parent directory”. But we can use another path shortcut to avoid changing directory at all. In the same way that two dots (`..`) represents the parent directory, so a single dot (`.`) can be used to represent the current working directory. Because we know there’s only one file in ***lab1*** we can also just use “\*” to match any filename in that directory, saving ourselves a few more keystrokes. Our command to move the file back into the working directory therefore becomes this (note the space before the dot, there are ***two*** parameters being passed to `mv`):

``` bash
mv lab1/* .
```

The `mv` command also lets us move more than one file at a time. If you pass more than two arguments, the last one is taken to be the destination directory and the others are considered to be files (or directories) to move. Let’s use a single command to move ***lab.log***, all our ***\*.statue*** files and ***lab2*** into ***lab3*** (now, it's getting trippy). There’s a bit more going on here, but if you look at each argument at a time you should be able to work out what’s happening:
****
``` bash
mv lab.log *.statue lab2 lab3
ls
ls lab3
```

Let's keep ***lab.log*** in ***lab3*** but everyhting else out:

```bash
mv lab3/lab? lab3/*.statue .
```

## Renaming Files

The `mv` command doesn't just move files between directories—it's also used to rename them. When you move a file to the same directory but give it a new name, you're effectively renaming it.

For example, let's rename one of our statue files:

``` bash

mv sydney_brenner.statue brenner_sydney.statue
cat brenner_sydney.statue
```

The file has been renamed, not moved to a different location.

## Copying Files

Sometimes you want to create a duplicate of a file. This is where the `cp` (**c**o**p**y) command comes in:

``` bash
cp brenner_sydney.statue sydney_brenner.statue
ls *.statue
```

You now have two files: the original and the last-name-first copy. The `cp` command can also work with directories, but you need to use an option to do so. To copy an entire directory and all its contents, use the `-r` option (which stands for "recursive"):

``` bash
cp -r lab4 lab6
ls
```

This creates a complete copy of `lab1` and all the files inside it, called `lab6`.

## Deleting Files and Directories

To remove files, use the `rm` (**r**e**m**o**v**e) command. Be careful with this—once deleted, files are generally gone for good!

``` bash
rm brenner_sydney.statue
ls *.statue
```

The backup is gone. We have enough labs for now. To remove a directory, add the `-r` option:

``` bash
rm -r lab6
ls
```

::: {.callout-caution title="Warning: rm is permanent"}
Unlike moving files to a trash or recycle bin on a graphical interface, `rm` permanently deletes files. There is no undo! Always double-check your command before pressing **Enter**.
:::


# A Bit of Plumbing

# The Command Line and the Superuser

# Hidden Files

# References

-   [Chapter 2 The Basics of the Unix Shell, Research Software Engineering with Python](https://third-bit.com/py-rse/bash-basics.html) by Wilson et al.
-   https://code.visualstudio.com/docs/terminal/basics
-   https://ubuntu.com/tutorials/command-line-for-beginners